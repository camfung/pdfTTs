is true if there is a breeze in . is true if there is a stench in . is true if the agent is in location . The sentences we write will suffice to derive (there is no pit in [1,2]), as was done informally in Section 7.3 . We label each sentence so that we can refer to them: There is no pit in [1,1]: A square is breezy if and only if there is a pit in a neighboring square. This has to be stated for each square; for now, we include just the relevant squares: The preceding sentences are true in all wumpus worlds. Now we include the breeze percepts for the first two squares visited in the specific world the agent is in, leading up to the situation in Figure 7.3(b) . B1,1 ⇔ (P1,2 ∨ P2,1) , B1,1 [x,y] Px,y [x,y] Wx,y [x,y] Bx,y [x,y] Sx,y [x,y] Lx,y [x,y] ¬P1,2  Ri R1 : ¬P1,1 . R2 : B1,1 ⇔ (P1,2 ∨ P2,1) . R3 : B2,1 ⇔ (P1,1 ∨ P2,2 ∨ P3,1) .  7.4.4 A simple inference procedure Our goal now is to decide whether for some sentence . For example, is entailed by our ? Our first algorithm for inference is a model-checking approach that is a direct implementation of the definition of entailment: enumerate the models, and check that is true in every model in which is true. Models are assignments of true or false to every proposition symbol. Returning to our wumpus-world example, the relevant proposition symbols are , , , , , , and . With seven symbols, there are possible models; in three of these, is true (Figure 7.9 ). In those three models, is true, hence there is no pit in [1,2]. On the other hand, is true in two of the three models and false in one, so we cannot yet tell whether there is a pit in [2,2]. Figure 7.9 A truth table constructed for the knowledge base given in the text. is true if through are true, which occurs in just 3 of the 128 rows (the ones underlined in the right-hand column). In all 3 rows, is false, so there is no pit in [1,2]. On the other hand, there might (or might not) be a pit in [2,2]. Figure 7.9 reproduces in a more precise form the reasoning illustrated in Figure 7.5 . A general algorithm for deciding entailment in propositional logic is shown in Figure 7.10 . Like the BACKTRACKING-SEARCH algorithm on page 192, TT-ENTAILS? performs a recursive enumeration of a finite space of assignments to symbols. The algorithm is sound because it implements directly the definition of entailment, and complete because it works for any and and always terminates—there are only finitely many models to examine. R4 : ¬B1,1 . R5 : B2,1 . KB ⊨ α α ¬P1,2 KB α KB B1,1 B2,1 P1,1 P1,2 P2,1 P2,2 P3,1 27 = 128 KB  ¬P1,2 P2,2 KB R1 R5 P1,2    KB α Figure 7.10 A truth-table enumeration algorithm for deciding propositional entailment. (TT stands for truth table.) PL-TRUE? returns true if a sentence holds within a model. The variable model represents a partial model— an assignment to some of the symbols. The keyword and here is an infix function symbol in the pseudocode programming language, not an operator in proposition logic; it takes two arguments and returns true or false. Of course, “finitely many” is not always the same as “few.” If and contain symbols in all, then there are models. Thus, the time complexity of the algorithm is . (The space complexity is only because the enumeration is depth-first.) Later in this chapter we show algorithms that are much more efficient in many cases. Unfortunately, propositional entailment is co-NP-complete (i.e., probably no easier than NP-complete—see Appendix A ), so every known inference algorithm for propositional logic has a worst-case complexity that is exponential in the size of the input. KB α n 2n O(2n) O(n) 