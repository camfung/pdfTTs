Euclid’s algorithm, and other ways to calculate the greatest common divisor, see Section 4.5.2. Analysis of algorithms is the name the author likes to use to describe in- vestigations such as this. The general idea is to take a particular algorithm and to determine its quantitative behavior; occasionally we also study whether or not an algorithm is optimal in some sense. The theory of algorithms is another subject entirely, dealing primarily with the existence or nonexistence of effective algorithms to compute particular quantities. So far our discussion of algorithms has been rather imprecise, and a mathe- matically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms. We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, Ω, f), in which Q is a set containing subsets I and Ω, and f is a function from Q into itself. Furthermore f should leave Ω pointwise fixed; that is, f(q) should equal q for all elements q of Ω. The four quantities Q, I, Ω, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational 8 BASIC CONCEPTS 1.1 sequence, x0, x1, x2, . . . , as follows: x0 = x and xk+1 = f(xk) for k ≥ 0. (1) The computational sequence is said to terminate in k steps if k is the smallest integer for which xk is in Ω, and in this case it is said to produce the output xk from x. (Notice that if xk is in Ω, so is xk+1, because xk+1 = xk in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I. Algorithm E may, for example, be formalized in these terms as follows: Let Q be the set of all singletons (n), all ordered pairs (m, n), and all ordered quadruples (m, n, r, 1), (m, n, r, 2), and (m, n, p, 3), where m, n, and p are positive integers and r is a nonnegative integer. Let I be the subset of all pairs (m, n) and let Ω be the subset of all singletons (n). Let f be defined as follows: f  (m, n)  = (m, n, 0, 1); f  (n)  = (n); f  (m, n, r, 1)  = (m, n, remainder of m divided by n, 2); f  (m, n, r, 2)  = (n) if r = 0, (m, n, r, 3) otherwise; f  (m, n, p, 3)  = (n, p, p, 1). (2) The correspondence between this notation and Algorithm E is evident. This formulation of the concept of an algorithm does not include the re- striction of effectiveness mentioned earlier. For example, Q might denote infinite sequences that are not computable by pencil and paper methods, or f might involve operations that mere mortals cannot always perform. If we wish to restrict the notion of algorithm so that only elementary operations are involved, we can place restrictions on Q, I, Ω, and f, for example as follows: Let A be a finite set of letters, and let A∗ be the set of all strings on A (the set of all ordered sequences x1x2 . . . xn, where n ≥ 0 and xj is in A for 1 ≤ j ≤ n). The idea is to encode the states of the computation so that they are represented by strings of A∗. Now let N be a nonnegative integer and let Q be the set of all (σ, j), where σ is in A∗ and j is an integer, 0 ≤ j ≤ N; let I be the subset of Q with j = 0 and let Ω be the subset with j = N. If θ and σ are strings in A∗, we say that θ occurs in σ if σ has the form αθω for strings α and ω. To complete our definition, let f be a function of the following type, defined by the strings θj, ϕj and the integers aj, bj for 0 ≤ j < N: f  (σ, j)  =(σ, aj) if θj does not occur in σ; f  (σ, j)  =(αϕjω, bj) if α is the shortest possible string for which σ =αθjω; f  (σ, N)  =(σ, N). (3) Every step of such a computational method is clearly effective, and expe- rience shows that pattern-matching rules of